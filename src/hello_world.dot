set greet(){
    world(s_ 'name:){
        name"
    } 'name\ // pseudo-ephemeral termination still applies -> symbol goes out of scope, even if it points to a const
}

s_ string" = "Hello, world!":
greet.world('string:) // no ; after ) as only single const arg passed, so no non-ephemeral memory is being modified

'string\ // you may terminate const if no longer used

set max_of(i_5 'arr, i_ 'max,) {
    max" = arr"0, // must end in ;, you're modifying a non ephemeral outside the function {}
    i_ 'i, // this is actually correct! but strange. why declare a non-ephemeral here? it's safe! just use i, you're in a function body.  you accidentally got the , correct, as it's not modifying non-ephemeral outside of function, , is valid
    i" = 1,

    while(i" < 5,) { 
        if(arr"i > max") {
            max" = arr"i, // almost darling but you've declared i as 'type, so you must dereference like arr"i" even though it dies by }. all variables defined within function die by final }â€” only the pseudos make it past }, only to die of cold-shock
        }
        i" = i" + 1,
    }

    'i\ 'max\ 'arr\ /// noooooooooo. 'i/? no variable defined inside a function lives past }. only parameter symbols survive... until
} // 'max\ 'arr\


set_i one{f(i_ 'a){
    //definition
    a"++;
}} //sets with type restrictions

set_i_s two{    // multi-type set
    g(i_ 'a, s_ 'g){} // takes i_ and s_
    k(i_ 'a) {} // only accepts i_ type
}

struct_i vec{
    i_ 'x;
    i_ 'y; // no ephemerals allowed they die by }
}

~struct_i vec{ //not overwriting vec, as heap ~ type
    i_ 'x;
    i_ 'y;
}

i_vec point{x" = 2; y" = 3;}
~i_vec point{x" = 2; y" = 3;}

~point" += point"; // like bit or merge, wraps or duplicates if different number of members
// i just used heap here to show you can clarify between identically named structs and instances if one is on the heap and the other isn't, because they are treated like distinct symbols

// using the set from earlier

point"x.one.f();
// equivalent notation is
one.f(point"x) // prints 3

//NEW SYNTAX RULE!!!! VERY MAJOR

function(i_ *e){ //notice anything special here? parameters now use ` instead of ' to distinguish them. it's subtle, forces the programmer to understand it's a pseudo to use it
    i_ temp = e*  // dereferencing a pseudo (symbol is ephemeral, memory it accesses isn't, a duality of scope in a sense)
    i
} //no longer need to do `e\. it's a pseudo, doesn't survive.

//now check this out
// remember: function('i;); BYE UGLY
function('i) // out here, it's not a pseudo, so 'i instead of *i. function doesn't modify non-ephemerals, so no terminating ;